{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nimport color from 'color';\nimport { MD3LightTheme } from \"../../styles/themes\";\nimport { AdornmentSide, AdornmentType } from \"./Adornment/enums\";\nimport { ADORNMENT_SIZE, MD2_ADORNMENT_OFFSET, MD2_AFFIX_OFFSET, MD2_FLAT_INPUT_OFFSET, MD2_ICON_OFFSET, MD2_INPUT_PADDING_HORIZONTAL, MD2_LABEL_PADDING_HORIZONTAL, MD2_LABEL_PADDING_TOP, MD2_MIN_HEIGHT, MD2_OUTLINED_INPUT_OFFSET, MD3_ADORNMENT_OFFSET, MD3_AFFIX_OFFSET, MD3_FLAT_INPUT_OFFSET, MD3_ICON_OFFSET, MD3_INPUT_PADDING_HORIZONTAL, MD3_LABEL_PADDING_HORIZONTAL, MD3_LABEL_PADDING_TOP, MD3_MIN_HEIGHT, MD3_OUTLINED_INPUT_OFFSET } from \"./constants\";\nexport var calculateLabelTopPosition = function calculateLabelTopPosition(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var optionalPadding = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var customHeight = height > 0 ? height : 0;\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\nexport var calculateInputHeight = function calculateInputHeight(labelHeight) {\n  var height = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  var minHeight = arguments.length > 2 ? arguments[2] : undefined;\n  var finalHeight = height > 0 ? height : labelHeight;\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\nexport var calculatePadding = function calculatePadding(props) {\n  var height = props.height,\n      _props$multiline = props.multiline,\n      multiline = _props$multiline === void 0 ? false : _props$multiline;\n  var result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nvar calculateTextAreaPadding = function calculateTextAreaPadding(props) {\n  var dense = props.dense;\n  return dense ? 10 : 20;\n};\n\nvar calculateInputPadding = function calculateInputPadding(_ref) {\n  var topPosition = _ref.topPosition,\n      fontSize = _ref.fontSize,\n      multiline = _ref.multiline,\n      scale = _ref.scale,\n      dense = _ref.dense,\n      offset = _ref.offset,\n      isAndroid = _ref.isAndroid;\n  var refFontSize = scale * fontSize;\n  var result = Math.floor(topPosition / 2);\n  result = result + Math.floor((refFontSize - fontSize) / 2) - (scale < 1 ? offset / 2 : 0);\n  if (multiline && isAndroid) result = Math.min(dense ? offset / 2 : offset, result);\n  return result;\n};\n\nexport var adjustPaddingOut = function adjustPaddingOut(_ref2) {\n  var pad = _ref2.pad,\n      multiline = _ref2.multiline,\n      label = _ref2.label,\n      scale = _ref2.scale,\n      height = _ref2.height,\n      fontSize = _ref2.fontSize,\n      lineHeight = _ref2.lineHeight,\n      dense = _ref2.dense,\n      offset = _ref2.offset,\n      isAndroid = _ref2.isAndroid;\n  var fontHeight = lineHeight !== null && lineHeight !== void 0 ? lineHeight : fontSize;\n  var refFontHeight = scale * fontSize;\n  var result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2)\n    };\n  }\n\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight / 2 * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n\n    if (!dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, refFontHeight * scale) : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n\n    result = Math.floor(result);\n  }\n\n  return {\n    paddingTop: result,\n    paddingBottom: result\n  };\n};\nexport var adjustPaddingFlat = function adjustPaddingFlat(_ref3) {\n  var pad = _ref3.pad,\n      scale = _ref3.scale,\n      multiline = _ref3.multiline,\n      label = _ref3.label,\n      height = _ref3.height,\n      offset = _ref3.offset,\n      dense = _ref3.dense,\n      fontSize = _ref3.fontSize,\n      isAndroid = _ref3.isAndroid,\n      styles = _ref3.styles;\n  var result = pad;\n  var topResult = result;\n  var bottomResult = result;\n  var paddingTop = styles.paddingTop,\n      paddingBottom = styles.paddingBottom;\n  var refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    if (label) {\n      return {\n        paddingTop: paddingTop,\n        paddingBottom: paddingBottom\n      };\n    }\n\n    return {\n      paddingTop: result,\n      paddingBottom: result\n    };\n  }\n\n  if (label) {\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    if (!isAndroid) {\n      if (dense) {\n        topResult += scale < 1 ? Math.min(result, refFontSize * scale) - result / 2 : Math.min(result, refFontSize * scale) - result / 2;\n      }\n\n      if (!dense) {\n        topResult += scale < 1 ? Math.min(offset / 2, refFontSize * scale) : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2)\n      };\n    }\n\n    if (!isAndroid) {\n      if (dense) {\n        result += scale < 1 ? Math.min(offset / 2, fontSize / 2 * scale) : Math.min(offset / 2, scale);\n      }\n\n      if (!dense) {\n        result += scale < 1 ? Math.min(offset, fontSize * scale) : Math.min(fontSize, offset / 2 * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult)\n  };\n};\nexport var interpolatePlaceholder = function interpolatePlaceholder(labeled, hasActiveOutline) {\n  return labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1]\n  });\n};\nexport function calculateFlatAffixTopPosition(_ref4) {\n  var height = _ref4.height,\n      paddingTop = _ref4.paddingTop,\n      paddingBottom = _ref4.paddingBottom,\n      affixHeight = _ref4.affixHeight;\n  var inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n  var halfOfTheInputHeightDecreasedByAffixHeight = (inputHeightWithoutPadding - affixHeight) / 2;\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\nexport function calculateOutlinedIconAndAffixTopPosition(_ref5) {\n  var height = _ref5.height,\n      affixHeight = _ref5.affixHeight,\n      labelYOffset = _ref5.labelYOffset;\n  return (height - affixHeight + labelYOffset) / 2;\n}\nexport var calculateFlatInputHorizontalPadding = function calculateFlatInputHorizontalPadding(_ref6) {\n  var adornmentConfig = _ref6.adornmentConfig,\n      isV3 = _ref6.isV3;\n\n  var _getConstants = getConstants(isV3),\n      LABEL_PADDING_HORIZONTAL = _getConstants.LABEL_PADDING_HORIZONTAL,\n      ADORNMENT_OFFSET = _getConstants.ADORNMENT_OFFSET,\n      FLAT_INPUT_OFFSET = _getConstants.FLAT_INPUT_OFFSET;\n\n  var paddingLeft = LABEL_PADDING_HORIZONTAL;\n  var paddingRight = LABEL_PADDING_HORIZONTAL;\n  adornmentConfig.forEach(function (_ref7) {\n    var type = _ref7.type,\n        side = _ref7.side;\n\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n  return {\n    paddingLeft: paddingLeft,\n    paddingRight: paddingRight\n  };\n};\n\nvar getInputTextColor = function getInputTextColor(_ref8) {\n  var theme = _ref8.theme,\n      textColor = _ref8.textColor,\n      disabled = _ref8.disabled,\n      mode = _ref8.mode;\n  var isFlat = mode === 'flat';\n\n  if (textColor) {\n    return textColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    if (isFlat) {\n      return theme.colors.onSurfaceVariant;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.text;\n};\n\nvar getActiveColor = function getActiveColor(_ref9) {\n  var theme = _ref9.theme,\n      disabled = _ref9.disabled,\n      error = _ref9.error,\n      activeUnderlineColor = _ref9.activeUnderlineColor,\n      activeOutlineColor = _ref9.activeOutlineColor,\n      mode = _ref9.mode;\n  var isFlat = mode === 'flat';\n  var modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n\n  if (error) {\n    return theme.colors.error;\n  }\n\n  if (modeColor) {\n    return modeColor;\n  }\n\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.primary;\n};\n\nvar getPlaceholderColor = function getPlaceholderColor(_ref10) {\n  var theme = _ref10.theme,\n      disabled = _ref10.disabled;\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurfaceVariant;\n  }\n\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n\n  return theme.colors.placeholder;\n};\n\nvar getFlatBackgroundColor = function getFlatBackgroundColor(_ref11) {\n  var _theme$colors, _theme$colors2;\n\n  var theme = _ref11.theme,\n      disabled = _ref11.disabled;\n\n  if (theme.isV3) {\n    if (disabled) {\n      return color(MD3LightTheme.colors.onSecondaryContainer).alpha(0.08).rgb().string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n\n  if (disabled) {\n    return undefined;\n  }\n\n  return theme.dark ? color((_theme$colors = theme.colors) === null || _theme$colors === void 0 ? void 0 : _theme$colors.background).lighten(0.24).rgb().string() : color((_theme$colors2 = theme.colors) === null || _theme$colors2 === void 0 ? void 0 : _theme$colors2.background).darken(0.06).rgb().string();\n};\n\nvar getFlatUnderlineColor = function getFlatUnderlineColor(_ref12) {\n  var theme = _ref12.theme,\n      disabled = _ref12.disabled,\n      underlineColor = _ref12.underlineColor;\n\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return 'transparent';\n  }\n\n  return theme.colors.disabled;\n};\n\nvar getOutlinedOutlineInputColor = function getOutlinedOutlineInputColor(_ref13) {\n  var theme = _ref13.theme,\n      disabled = _ref13.disabled,\n      customOutlineColor = _ref13.customOutlineColor;\n  var isTransparent = color(customOutlineColor).alpha() === 0;\n\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n\n      return theme.colors.surfaceDisabled;\n    }\n\n    return theme.colors.outline;\n  }\n\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n\n    return theme.colors.disabled;\n  }\n\n  return theme.colors.placeholder;\n};\n\nexport var getFlatInputColors = function getFlatInputColors(_ref14) {\n  var underlineColor = _ref14.underlineColor,\n      activeUnderlineColor = _ref14.activeUnderlineColor,\n      textColor = _ref14.textColor,\n      disabled = _ref14.disabled,\n      error = _ref14.error,\n      theme = _ref14.theme;\n  var baseFlatColorProps = {\n    theme: theme,\n    disabled: disabled\n  };\n  return {\n    inputTextColor: getInputTextColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      textColor: textColor,\n      mode: 'flat'\n    })),\n    activeColor: getActiveColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      error: error,\n      activeUnderlineColor: activeUnderlineColor,\n      mode: 'flat'\n    })),\n    underlineColorCustom: getFlatUnderlineColor(_objectSpread(_objectSpread({}, baseFlatColorProps), {}, {\n      underlineColor: underlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps)\n  };\n};\nexport var getOutlinedInputColors = function getOutlinedInputColors(_ref15) {\n  var activeOutlineColor = _ref15.activeOutlineColor,\n      customOutlineColor = _ref15.customOutlineColor,\n      textColor = _ref15.textColor,\n      disabled = _ref15.disabled,\n      error = _ref15.error,\n      theme = _ref15.theme;\n  var baseOutlinedColorProps = {\n    theme: theme,\n    disabled: disabled\n  };\n  return {\n    inputTextColor: getInputTextColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      textColor: textColor,\n      mode: 'outlined'\n    })),\n    activeColor: getActiveColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      error: error,\n      activeOutlineColor: activeOutlineColor,\n      mode: 'outlined'\n    })),\n    outlineColor: getOutlinedOutlineInputColor(_objectSpread(_objectSpread({}, baseOutlinedColorProps), {}, {\n      customOutlineColor: customOutlineColor\n    })),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    errorColor: theme.colors.error\n  };\n};\nexport var getConstants = function getConstants(isV3) {\n  var AFFIX_OFFSET;\n  var ICON_OFFSET;\n  var LABEL_PADDING_TOP;\n  var LABEL_PADDING_HORIZONTAL;\n  var FLAT_INPUT_OFFSET;\n  var MIN_HEIGHT;\n  var INPUT_PADDING_HORIZONTAL;\n  var ADORNMENT_OFFSET;\n  var OUTLINED_INPUT_OFFSET;\n\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n\n  return {\n    AFFIX_OFFSET: AFFIX_OFFSET,\n    ICON_OFFSET: ICON_OFFSET,\n    LABEL_PADDING_TOP: LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL: LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET: FLAT_INPUT_OFFSET,\n    MIN_HEIGHT: MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL: INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET: ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET: OUTLINED_INPUT_OFFSET\n  };\n};","map":{"version":3,"sources":["helpers.tsx"],"names":["color","MD3LightTheme","AdornmentSide","AdornmentType","ADORNMENT_SIZE","MD2_ADORNMENT_OFFSET","MD2_AFFIX_OFFSET","MD2_FLAT_INPUT_OFFSET","MD2_ICON_OFFSET","MD2_INPUT_PADDING_HORIZONTAL","MD2_LABEL_PADDING_HORIZONTAL","MD2_LABEL_PADDING_TOP","MD2_MIN_HEIGHT","MD2_OUTLINED_INPUT_OFFSET","MD3_ADORNMENT_OFFSET","MD3_AFFIX_OFFSET","MD3_FLAT_INPUT_OFFSET","MD3_ICON_OFFSET","MD3_INPUT_PADDING_HORIZONTAL","MD3_LABEL_PADDING_HORIZONTAL","MD3_LABEL_PADDING_TOP","MD3_MIN_HEIGHT","MD3_OUTLINED_INPUT_OFFSET","calculateLabelTopPosition","labelHeight","height","optionalPadding","customHeight","Math","floor","calculateInputHeight","minHeight","finalHeight","calculatePadding","props","multiline","result","calculateTextAreaPadding","calculateInputPadding","max","dense","topPosition","fontSize","scale","offset","isAndroid","refFontSize","min","adjustPaddingOut","pad","label","lineHeight","fontHeight","refFontHeight","paddingTop","paddingBottom","adjustPaddingFlat","styles","topResult","bottomResult","interpolatePlaceholder","labeled","hasActiveOutline","interpolate","inputRange","outputRange","calculateFlatAffixTopPosition","affixHeight","inputHeightWithoutPadding","halfOfTheInputHeightDecreasedByAffixHeight","calculateOutlinedIconAndAffixTopPosition","labelYOffset","calculateFlatInputHorizontalPadding","adornmentConfig","isV3","LABEL_PADDING_HORIZONTAL","ADORNMENT_OFFSET","FLAT_INPUT_OFFSET","getConstants","paddingLeft","paddingRight","forEach","type","side","Icon","Left","Right","Affix","getInputTextColor","theme","textColor","disabled","mode","isFlat","colors","onSurfaceDisabled","onSurfaceVariant","onSurface","text","alpha","rgb","string","getActiveColor","error","activeUnderlineColor","activeOutlineColor","modeColor","primary","getPlaceholderColor","placeholder","getFlatBackgroundColor","onSecondaryContainer","surfaceVariant","undefined","dark","background","lighten","darken","getFlatUnderlineColor","underlineColor","getOutlinedOutlineInputColor","customOutlineColor","isTransparent","surfaceDisabled","outline","getFlatInputColors","baseFlatColorProps","inputTextColor","activeColor","underlineColorCustom","placeholderColor","errorColor","backgroundColor","getOutlinedInputColors","baseOutlinedColorProps","outlineColor","AFFIX_OFFSET","ICON_OFFSET","LABEL_PADDING_TOP","MIN_HEIGHT","INPUT_PADDING_HORIZONTAL","OUTLINED_INPUT_OFFSET"],"mappings":"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","sourcesContent":["import type { Animated } from 'react-native';\n\nimport color from 'color';\n\nimport { MD3LightTheme } from '../../styles/themes';\nimport type { InternalTheme } from '../../types';\nimport { AdornmentSide, AdornmentType } from './Adornment/enums';\nimport type { AdornmentConfig } from './Adornment/types';\nimport {\n  ADORNMENT_SIZE,\n  MD2_ADORNMENT_OFFSET,\n  MD2_AFFIX_OFFSET,\n  MD2_FLAT_INPUT_OFFSET,\n  MD2_ICON_OFFSET,\n  MD2_INPUT_PADDING_HORIZONTAL,\n  MD2_LABEL_PADDING_HORIZONTAL,\n  MD2_LABEL_PADDING_TOP,\n  MD2_MIN_HEIGHT,\n  MD2_OUTLINED_INPUT_OFFSET,\n  MD3_ADORNMENT_OFFSET,\n  MD3_AFFIX_OFFSET,\n  MD3_FLAT_INPUT_OFFSET,\n  MD3_ICON_OFFSET,\n  MD3_INPUT_PADDING_HORIZONTAL,\n  MD3_LABEL_PADDING_HORIZONTAL,\n  MD3_LABEL_PADDING_TOP,\n  MD3_MIN_HEIGHT,\n  MD3_OUTLINED_INPUT_OFFSET,\n} from './constants';\nimport type { TextInputLabelProp } from './types';\n\ntype PaddingProps = {\n  height: number | null;\n  labelHalfHeight: number;\n  multiline: boolean | null;\n  dense: boolean | null;\n  topPosition: number;\n  fontSize: number;\n  lineHeight?: number;\n  label?: TextInputLabelProp | null;\n  scale: number;\n  offset: number;\n  isAndroid: boolean;\n  styles: { paddingTop: number; paddingBottom: number };\n};\n\ntype AdjProps = PaddingProps & {\n  pad: number;\n};\n\nexport type Padding = { paddingTop: number; paddingBottom: number };\n\nexport const calculateLabelTopPosition = (\n  labelHeight: number,\n  height: number = 0,\n  optionalPadding: number = 0\n): number => {\n  const customHeight = height > 0 ? height : 0;\n\n  return Math.floor((customHeight - labelHeight) / 2 + optionalPadding);\n};\n\nexport const calculateInputHeight = (\n  labelHeight: number,\n  height: any = 0,\n  minHeight: number\n): number => {\n  const finalHeight = height > 0 ? height : labelHeight;\n\n  if (height > 0) return height;\n  return finalHeight < minHeight ? minHeight : finalHeight;\n};\n\nexport const calculatePadding = (props: PaddingProps): number => {\n  const { height, multiline = false } = props;\n\n  let result = 0;\n\n  if (multiline) {\n    if (height && multiline) {\n      result = calculateTextAreaPadding(props);\n    } else {\n      result = calculateInputPadding(props);\n    }\n  }\n\n  return Math.max(0, result);\n};\n\nconst calculateTextAreaPadding = (props: PaddingProps) => {\n  const { dense } = props;\n\n  return dense ? 10 : 20;\n};\n\nconst calculateInputPadding = ({\n  topPosition,\n  fontSize,\n  multiline,\n  scale,\n  dense,\n  offset,\n  isAndroid,\n}: PaddingProps): number => {\n  const refFontSize = scale * fontSize;\n  let result = Math.floor(topPosition / 2);\n\n  result =\n    result +\n    Math.floor((refFontSize - fontSize) / 2) -\n    (scale < 1 ? offset / 2 : 0);\n\n  if (multiline && isAndroid)\n    result = Math.min(dense ? offset / 2 : offset, result);\n\n  return result;\n};\n\nexport const adjustPaddingOut = ({\n  pad,\n  multiline,\n  label,\n  scale,\n  height,\n  fontSize,\n  lineHeight,\n  dense,\n  offset,\n  isAndroid,\n}: AdjProps): Padding => {\n  const fontHeight = lineHeight ?? fontSize;\n  const refFontHeight = scale * fontSize;\n  let result = pad;\n\n  if (height && !multiline) {\n    return {\n      paddingTop: Math.max(0, (height - fontHeight) / 2),\n      paddingBottom: Math.max(0, (height - fontHeight) / 2),\n    };\n  }\n  if (!isAndroid && multiline) {\n    if (dense) {\n      if (label) {\n        result += scale < 1 ? Math.min(offset, (refFontHeight / 2) * scale) : 0;\n      } else {\n        result += 0;\n      }\n    }\n    if (!dense) {\n      if (label) {\n        result +=\n          scale < 1\n            ? Math.min(offset, refFontHeight * scale)\n            : Math.min(offset / 2, refFontHeight * scale);\n      } else {\n        result += scale < 1 ? Math.min(offset / 2, refFontHeight * scale) : 0;\n      }\n    }\n    result = Math.floor(result);\n  }\n  return { paddingTop: result, paddingBottom: result };\n};\n\nexport const adjustPaddingFlat = ({\n  pad,\n  scale,\n  multiline,\n  label,\n  height,\n  offset,\n  dense,\n  fontSize,\n  isAndroid,\n  styles,\n}: AdjProps): Padding => {\n  let result = pad;\n  let topResult = result;\n  let bottomResult = result;\n  const { paddingTop, paddingBottom } = styles;\n  const refFontSize = scale * fontSize;\n\n  if (!multiline) {\n    // do not modify padding if input is not multiline\n    if (label) {\n      // return const style for flat input with label\n      return { paddingTop, paddingBottom };\n    }\n    // return pad for flat input without label\n    return { paddingTop: result, paddingBottom: result };\n  }\n\n  if (label) {\n    // add paddings passed from styles\n    topResult = paddingTop;\n    bottomResult = paddingBottom;\n\n    // adjust top padding for iOS\n    if (!isAndroid) {\n      if (dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(result, refFontSize * scale) - result / 2\n            : Math.min(result, refFontSize * scale) - result / 2;\n      }\n      if (!dense) {\n        topResult +=\n          scale < 1\n            ? Math.min(offset / 2, refFontSize * scale)\n            : Math.min(result, refFontSize * scale) - offset / 2;\n      }\n    }\n    topResult = Math.floor(topResult);\n  } else {\n    if (height) {\n      // center text when height is passed\n      return {\n        paddingTop: Math.max(0, (height - fontSize) / 2),\n        paddingBottom: Math.max(0, (height - fontSize) / 2),\n      };\n    }\n    // adjust paddings for iOS if no label\n    if (!isAndroid) {\n      if (dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset / 2, (fontSize / 2) * scale)\n            : Math.min(offset / 2, scale);\n      }\n      if (!dense) {\n        result +=\n          scale < 1\n            ? Math.min(offset, fontSize * scale)\n            : Math.min(fontSize, (offset / 2) * scale);\n      }\n\n      result = Math.floor(result);\n      topResult = result;\n      bottomResult = result;\n    }\n  }\n\n  return {\n    paddingTop: Math.max(0, topResult),\n    paddingBottom: Math.max(0, bottomResult),\n  };\n};\n\nexport const interpolatePlaceholder = (\n  labeled: Animated.Value,\n  hasActiveOutline: boolean | undefined\n) =>\n  labeled.interpolate({\n    inputRange: [0, 1],\n    outputRange: [hasActiveOutline ? 0 : 1, 1],\n  });\n\nexport function calculateFlatAffixTopPosition({\n  height,\n  paddingTop,\n  paddingBottom,\n  affixHeight,\n}: {\n  height: number;\n  paddingTop: number;\n  paddingBottom: number;\n  affixHeight: number;\n}): number {\n  const inputHeightWithoutPadding = height - paddingTop - paddingBottom;\n\n  const halfOfTheInputHeightDecreasedByAffixHeight =\n    (inputHeightWithoutPadding - affixHeight) / 2;\n\n  return paddingTop + halfOfTheInputHeightDecreasedByAffixHeight;\n}\n\nexport function calculateOutlinedIconAndAffixTopPosition({\n  height,\n  affixHeight,\n  labelYOffset,\n}: {\n  height: number;\n  affixHeight: number;\n  labelYOffset: number;\n}): number {\n  return (height - affixHeight + labelYOffset) / 2;\n}\n\nexport const calculateFlatInputHorizontalPadding = ({\n  adornmentConfig,\n  isV3,\n}: {\n  adornmentConfig: AdornmentConfig[];\n  isV3?: boolean;\n}) => {\n  const { LABEL_PADDING_HORIZONTAL, ADORNMENT_OFFSET, FLAT_INPUT_OFFSET } =\n    getConstants(isV3);\n\n  let paddingLeft = LABEL_PADDING_HORIZONTAL;\n  let paddingRight = LABEL_PADDING_HORIZONTAL;\n\n  adornmentConfig.forEach(({ type, side }) => {\n    if (type === AdornmentType.Icon && side === AdornmentSide.Left) {\n      paddingLeft = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n    } else if (side === AdornmentSide.Right) {\n      if (type === AdornmentType.Affix) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      } else if (type === AdornmentType.Icon) {\n        paddingRight = ADORNMENT_SIZE + ADORNMENT_OFFSET + FLAT_INPUT_OFFSET;\n      }\n    }\n  });\n\n  return { paddingLeft, paddingRight };\n};\n\ntype BaseProps = {\n  theme: InternalTheme;\n  disabled?: boolean;\n};\n\ntype Mode = 'flat' | 'outlined';\n\nconst getInputTextColor = ({\n  theme,\n  textColor,\n  disabled,\n  mode,\n}: BaseProps & { mode: Mode; textColor?: string }) => {\n  const isFlat = mode === 'flat';\n  if (textColor) {\n    return textColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    if (isFlat) {\n      return theme.colors.onSurfaceVariant;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.text;\n};\n\nconst getActiveColor = ({\n  theme,\n  disabled,\n  error,\n  activeUnderlineColor,\n  activeOutlineColor,\n  mode,\n}: BaseProps & {\n  error?: boolean;\n  activeUnderlineColor?: string;\n  activeOutlineColor?: string;\n  mode?: Mode;\n}) => {\n  const isFlat = mode === 'flat';\n  const modeColor = isFlat ? activeUnderlineColor : activeOutlineColor;\n\n  if (error) {\n    return theme.colors.error;\n  }\n\n  if (modeColor) {\n    return modeColor;\n  }\n\n  if (disabled) {\n    if (theme.isV3) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return color(theme.colors.text).alpha(0.54).rgb().string();\n  }\n\n  return theme.colors.primary;\n};\n\nconst getPlaceholderColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurfaceVariant;\n  }\n\n  if (disabled) {\n    return theme.colors.disabled;\n  }\n\n  return theme.colors.placeholder;\n};\n\nconst getFlatBackgroundColor = ({ theme, disabled }: BaseProps) => {\n  if (theme.isV3) {\n    if (disabled) {\n      // @ts-ignore According to Figma for both themes the base color for disabled in `onSecondaryContainer`\n      return color(MD3LightTheme.colors.onSecondaryContainer)\n        .alpha(0.08)\n        .rgb()\n        .string();\n    } else {\n      return theme.colors.surfaceVariant;\n    }\n  }\n\n  if (disabled) {\n    return undefined;\n  }\n\n  return theme.dark\n    ? color(theme.colors?.background).lighten(0.24).rgb().string()\n    : color(theme.colors?.background).darken(0.06).rgb().string();\n};\n\nconst getFlatUnderlineColor = ({\n  theme,\n  disabled,\n  underlineColor,\n}: BaseProps & { underlineColor?: string }) => {\n  if (!disabled && underlineColor) {\n    return underlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      return theme.colors.onSurfaceDisabled;\n    }\n\n    return theme.colors.onSurface;\n  }\n\n  if (disabled) {\n    return 'transparent';\n  }\n\n  return theme.colors.disabled;\n};\n\nconst getOutlinedOutlineInputColor = ({\n  theme,\n  disabled,\n  customOutlineColor,\n}: BaseProps & { customOutlineColor?: string }) => {\n  const isTransparent = color(customOutlineColor).alpha() === 0;\n\n  if (!disabled && customOutlineColor) {\n    return customOutlineColor;\n  }\n\n  if (theme.isV3) {\n    if (disabled) {\n      if (theme.dark) {\n        return 'transparent';\n      }\n      return theme.colors.surfaceDisabled;\n    }\n\n    return theme.colors.outline;\n  }\n\n  if (disabled) {\n    if (isTransparent) {\n      return customOutlineColor;\n    }\n    return theme.colors.disabled;\n  }\n  return theme.colors.placeholder;\n};\n\nexport const getFlatInputColors = ({\n  underlineColor,\n  activeUnderlineColor,\n  textColor,\n  disabled,\n  error,\n  theme,\n}: {\n  underlineColor?: string;\n  activeUnderlineColor?: string;\n  textColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: InternalTheme;\n}) => {\n  const baseFlatColorProps = { theme, disabled };\n  return {\n    inputTextColor: getInputTextColor({\n      ...baseFlatColorProps,\n      textColor,\n      mode: 'flat',\n    }),\n    activeColor: getActiveColor({\n      ...baseFlatColorProps,\n      error,\n      activeUnderlineColor,\n      mode: 'flat',\n    }),\n    underlineColorCustom: getFlatUnderlineColor({\n      ...baseFlatColorProps,\n      underlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseFlatColorProps),\n    errorColor: theme.colors.error,\n    backgroundColor: getFlatBackgroundColor(baseFlatColorProps),\n  };\n};\n\nexport const getOutlinedInputColors = ({\n  activeOutlineColor,\n  customOutlineColor,\n  textColor,\n  disabled,\n  error,\n  theme,\n}: {\n  activeOutlineColor?: string;\n  customOutlineColor?: string;\n  textColor?: string;\n  disabled?: boolean;\n  error?: boolean;\n  theme: InternalTheme;\n}) => {\n  const baseOutlinedColorProps = { theme, disabled };\n\n  return {\n    inputTextColor: getInputTextColor({\n      ...baseOutlinedColorProps,\n      textColor,\n      mode: 'outlined',\n    }),\n    activeColor: getActiveColor({\n      ...baseOutlinedColorProps,\n      error,\n      activeOutlineColor,\n      mode: 'outlined',\n    }),\n    outlineColor: getOutlinedOutlineInputColor({\n      ...baseOutlinedColorProps,\n      customOutlineColor,\n    }),\n    placeholderColor: getPlaceholderColor(baseOutlinedColorProps),\n    errorColor: theme.colors.error,\n  };\n};\n\nexport const getConstants = (isV3?: boolean) => {\n  // Text input affix\n  let AFFIX_OFFSET;\n  // Text input icon\n  let ICON_OFFSET;\n  //Text input flat\n  let LABEL_PADDING_TOP;\n  let LABEL_PADDING_HORIZONTAL;\n  let FLAT_INPUT_OFFSET;\n  let MIN_HEIGHT;\n  // Text input outlined;\n  let INPUT_PADDING_HORIZONTAL;\n  let ADORNMENT_OFFSET;\n  let OUTLINED_INPUT_OFFSET;\n\n  if (isV3) {\n    AFFIX_OFFSET = MD3_AFFIX_OFFSET;\n    ICON_OFFSET = MD3_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD3_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD3_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD3_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD3_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD3_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD3_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD3_OUTLINED_INPUT_OFFSET;\n  } else {\n    AFFIX_OFFSET = MD2_AFFIX_OFFSET;\n    ICON_OFFSET = MD2_ICON_OFFSET;\n    LABEL_PADDING_TOP = MD2_LABEL_PADDING_TOP;\n    LABEL_PADDING_HORIZONTAL = MD2_LABEL_PADDING_HORIZONTAL;\n    FLAT_INPUT_OFFSET = MD2_FLAT_INPUT_OFFSET;\n    MIN_HEIGHT = MD2_MIN_HEIGHT;\n    INPUT_PADDING_HORIZONTAL = MD2_INPUT_PADDING_HORIZONTAL;\n    ADORNMENT_OFFSET = MD2_ADORNMENT_OFFSET;\n    OUTLINED_INPUT_OFFSET = MD2_OUTLINED_INPUT_OFFSET;\n  }\n\n  return {\n    AFFIX_OFFSET,\n    ICON_OFFSET,\n    LABEL_PADDING_TOP,\n    LABEL_PADDING_HORIZONTAL,\n    FLAT_INPUT_OFFSET,\n    MIN_HEIGHT,\n    INPUT_PADDING_HORIZONTAL,\n    ADORNMENT_OFFSET,\n    OUTLINED_INPUT_OFFSET,\n  };\n};\n"]},"metadata":{},"sourceType":"module"}